# Introduction

# Bases fondamentales (pour tous les domaines)

üìö Objectif : Poser les fondations avant d‚Äôattaquer des sujets plus techniques.

**Concepts cl√©s :**

-   **Introduction √† l'informatique Binaire** : syst√®mes d‚Äôexploitation, CPU, RAM, stockage
-   **Commandes Linux & Shell** : ls, cd, grep, find, man, etc.
-   **Logique r√©seau de base** : IP, DNS, ports, pare-feu, etc.
-   **Notions Dev & Git** : Introduction au versioning, GitHub, CLI
-   \*\*\*\* : Terme simple + d√©finition courte

---

-   **Algorithmique :** complexit√© Big O, structures de donn√©es de base, algorithmes de tri/recherche
-   **Programmation :** paradigmes, concepts fondamentaux, gestion m√©moire, ma√Ætrise d'un langage
-   **Math√©matiques :** logique bool√©enne, th√©orie des graphes, probabilit√©s, math√©matiques discr√®tes
-   **Ligne de commande :** navigation, manipulation de fichiers, scripts bash
-   **Contr√¥le de version :** Git (clone, commit, push, pull, merge, branches)
-   **R√©solution de probl√®mes :** d√©composition, debug m√©thodique, documentation

---

üéØ Bases fondamentales (95/100)
Algorithmique et structures de donn√©es

Complexit√© algorithmique : notation Big O, analyse temporelle et spatiale, cas moyen/pire
Structures de donn√©es : tableaux, listes cha√Æn√©es, piles, files, arbres (binaires, AVL, B-tree), graphes, tables de hachage, heaps
Algorithmes de tri : tri √† bulles, insertion, s√©lection, fusion, rapide, par tas, radix
Algorithmes de recherche : lin√©aire, binaire, hashing, parcours d'arbres (DFS, BFS, A\*)
Techniques avanc√©es : programmation dynamique, algorithmes gloutons, diviser pour r√©gner, backtracking

Programmation fondamentale

Paradigmes : imp√©ratif, orient√© objet, fonctionnel, proc√©dural
Concepts de base : variables, types, boucles, conditions, fonctions, r√©cursivit√©
Gestion m√©moire : pile, tas, garbage collection, pointeurs, r√©f√©rences
Compilation vs interpr√©tation : diff√©rences, bytecode, JIT, AOT
Ma√Ætrise d'au moins 2 langages diff√©rents (bas niveau + haut niveau)

Architecture des syst√®mes

Architecture processeur : CPU, cache, pipeline, instructions, registres
Hi√©rarchie m√©moire : RAM, cache L1/L2/L3, stockage, m√©moire virtuelle
Syst√®mes num√©riques : binaire, hexad√©cimal, repr√©sentation des nombres
Concurrence : threads, processus, synchronisation, deadlocks, race conditions

Outils et m√©thodologies

Contr√¥le de version : Git avanc√© (rebase, cherry-pick, hooks, workflows)
Documentation : Markdown, diagrammes UML, sp√©cifications techniques
Debugging : techniques, outils, analyse post-mortem
Tests : TDD, BDD, tests unitaires/int√©gration
Logique et math√©matiques : alg√®bre de Boole, th√©orie des graphes, complexit√© computationnelle
