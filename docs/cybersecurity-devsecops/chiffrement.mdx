# Chiffrement

## **Introduction**

**Le chiffrement des donn√©es** est un pilier essentiel de la s√©curit√© informatique moderne. Il vise √† rendre des informations
**incompr√©hensibles pour quiconque** ne poss√©dant pas le secret ( _appel√© cl√©_ ) n√©cessaire pour les rendre √† nouveau lisibles.

:::note
On entend souvent le verbe **crypter** ( _ou le mot **cryptage**_ ) utilis√© √† tort en fran√ßais pour parler de chiffrement.
Sachez que la distinction entre **chiffrement** et **cryptage** est tr√®s simple. ( _Le terme ¬´ **crypter** ¬ª √©tant un abus de langage en
fran√ßais_ ).

:::

Les diff√©rents types de chiffrement ( _**sym√©trique** vs **asym√©trique**_ ) et leurs usages respectifs.
D'autres notions connexes souvent confondues avec le chiffrement:

-   le hachage ( _hashing_ )
-   l'encodage
-   la st√©ganographie

Un focus sur la mise en ≈ìuvre du chiffrement dans les communications ( _ex: protocole **HTTPS**/**TLS**_ ) avec l'illustration
d'un handshake de n√©gociation de cl√©. Le tout est pr√©sent√© de mani√®re professionnelle, avec des sch√©mas explicatifs
( _diagrammes Mermaid et illustrations_ ) pour clarifier ces concepts sans ambigu√Øt√©.

## **Terminologie :** _**`Chiffrer`** n'est pas **`crypter`**_

En fran√ßais, on ne _crypte_ pas des donn√©es, on les **chiffre**. Le mot _crypter_ est un anglicisme d√©riv√© de l'anglais **to encrypt**.
Son usage est consid√©r√© comme incorrect dans le contexte technique, car _chiffrer_ implique l'utilisation d'une cl√©, tandis que _crypter_
pris litt√©ralement signifierait ¬´ rendre illisible **sans cl√©** puis sans possibilit√© de d√©chiffrer ensuite ¬ª, ce qui n'a pas de sens
dans un √©change de donn√©es normal.

En d'autres termes :

:::info Chiffrer vs Crypter
Le terme _cryptage_ est qualifi√© d'**incorrect** par le **R√©f√©rentiel g√©n√©ral de s√©curit√© de l'ANSSI** ( Agence National des Syst√®mes de
S√©curit√©s de l'Information ), car ¬´ il reviendrait √† coder un fichier sans en conna√Ætre la cl√© et donc sans pouvoir le d√©coder ensuite ¬ª.
**On dira donc chiffrer** un message ( _le rendre illisible √† l'aide d'une cl√©_ ) et **d√©chiffrer pour l'op√©ration inverse** avec la cl√©.

Le mot **d√©crypter**, lui, signifie d√©coder un message chiffr√© sans poss√©der la cl√© ( _c'est du ¬´ cassage de code ¬ª_ ). Quant √† _crypter_,
mieux vaut l'√©viter : ¬´ **On ne crypte pas un fichier, on le chiffre** ¬ª.
:::

:::note
_Une exception historique subsiste dans le langage courant : on parle de ¬´ **cha√Ænes t√©l√©vis√©es crypt√©es** ¬ª pour les cha√Ænes li√© √† canal+.
Selon l'Acad√©mie fran√ßaise : ¬´ **on chiffre les messages et on crypte les cha√Ænes** ¬ª._
:::

Pour illustrer cette distinction fondamentale, voici un sch√©ma explicatif :

```mermaid
---
config:
  theme: 'neutral'
---
graph TD
    A[Message Original] --> B{Action<br />de Protection}
    B -->|Avec cl√© secr√®te| C[CHIFFRER]
    B -->|Sans cl√© - cassage| D[CRYPTER]

    C --> E[Message Chiffr√©<br/>R√©versible avec la cl√©]
    D --> F[Message Crypt√©<br/>Tentative de cassage]

    E & F --> G{Action<br />d'Acc√®s}

    G -.->|avec cl√© secr√®te| H[D√âCHIFFRER]
    G -.->|sans cl√© - analyse| I[D√âCRYPTER]

    H --> J[Message Original R√©cup√©r√©]
    I --> K[Tentative de R√©cup√©ration<br/>par cryptanalyse]

    style B fill:#f3f3e3
    style G fill:#f3f3e3
    style C fill:#e3f3e3
    style H fill:#e3f3e3
    style D fill:#f3e3e3
    style I fill:#f3e3e3
```

<br />

En r√©sum√©, nous utiliserons ici le terme **chiffrement** pour d√©signer les proc√©d√©s qui prot√®gent un message √† l'aide d'une cl√© secr√®te.
Le mot **cryptographie** quant √† lui d√©signe plus largement la science des messages secrets. Il englobe le chiffrement moderne √† cl√©, mais
aussi des techniques plus anciennes ou plus g√©n√©rales ( _codes, masquage, etc._ ). La **cryptologie** est encore plus g√©n√©rale et inclut la
cryptographie ( _art de chiffrer_ ) et la cryptanalyse ( _art de casser les chiffres ou de d√©crypter sans cl√©_ ).

### Hi√©rarchie des disciplines cryptologiques

> Comprendre le sens de chacun des **termes** nous rends plus fort !!

```mermaid
---
config:
    theme: 'neutral'
---
flowchart TB
    subgraph CRYPTOLOGIE
        direction LR
        subgraph CRYPTOGRAPHIE
            direction TB
            B[Art de prot√©ger]
            B --> D[Chiffrement √† Cl√©]
            B --> E[Codes Secrets]
            B --> F[Signatures Num√©riques]
            B --> G[St√©ganographie]
        end

        subgraph CRYPTANALYSE
            direction TB
            C[Art de casser]
            C --> H[Cassage de Chiffres]
            C --> I[D√©cryptage sans cl√©]
            C --> J[Analyse de Vuln√©rabilit√©s]
        end

    end

    style B fill:#e3e3f3
    style C fill:#e3e3f3
    style CRYPTOGRAPHIE fill:#e3f3e3
    style CRYPTANALYSE fill:#f3e3e3
```

_La Cryptologie est consid√©r√© comme la science des messages secrets._

## **Les deux grands types de chiffrement**

Il existe deux familles principales de m√©thodes pour chiffrer des donn√©es :

-   le **chiffrement sym√©trique**
-   le **chiffrement asym√©trique** ( _aussi appel√© chiffrement √† cl√© publique_ ).

Chacune a son fonctionnement propre, ses avantages et inconv√©nients, et elles sont souvent compl√©mentaires dans les syst√®mes modernes.

### Chiffrement **`sym√©trique`**

Le chiffrement sym√©trique utilise une **m√™me cl√© secr√®te** partag√©e entre l'exp√©diteur et le destinataire du message. La m√™me cl√© sert donc √†
chiffrer et √† d√©chiffrer les donn√©es.

:::note Exemple
Si **Alice** et **Bob** partagent au pr√©alable une **cl√© secr√®te K** par un canal s√©curis√©, **Alice peut chiffrer** un message en texte clair
pour le transformer en texte chiffr√© illisible √† l'aide de cette cl√© secr√®te K. **Bob**, disposant de la m√™me **cl√© secr√®te K** pourra
**d√©chiffrer** le message re√ßu et retrouver le texte original.
:::

:::info
**Cette approche sym√©trique** n√©cessite donc un accord pr√©alable sur la cl√© partag√©e, d√©fi que nous examinerons lors de l'√©tude des protocoles
de communication s√©curis√©e tels que le **handshake TLS**.
:::

#### Petit diagramme de s√©quence pour comprendre ce que √ßa signifie

```mermaid
---
config:
    theme: 'neutral'
---
sequenceDiagram
    participant A as Alice
    participant K as üîë Cl√© Secr√®te Partag√©e
    participant B as Bob

    Note over A,B: √âtape pr√©alable : partage s√©curis√© de la cl√© K

    A->>A: Chiffre "Message secret"<br/>avec cl√© K
    A->>B: Transmet message chiffr√©<br/>"X7k9mP2..."
    B->>B: D√©chiffre avec la m√™me cl√© K

    Note over B: Message "Message secret" r√©cup√©r√©

    rect rgb(225, 255, 225)
        Note over A,B: M√™me cl√© utilis√©e pour chiffrer ET d√©chiffrer
    end
```

<br />

:::info
Les algorithmes sym√©triques courants incluent **AES** ( _Advanced Encryption Standard_ ), **ChaCha20**, et l'obsol√®te **DES/3DES**.
Le chiffrement sym√©trique est pris√© pour sa **simplicit√© et sa rapidit√©** : il permet de chiffrer de grands volumes de donn√©es tr√®s
efficacement. De plus, tant que la cl√© reste secr√®te entre les deux parties, le syst√®me assure la confidentialit√© et m√™me l'int√©grit√© du
message.
:::

#### Avantages et inconv√©nients du chiffrement sym√©trique

> D√©couvrons les avantages et les inconv√©nients du **chiffrement sym√©trique**

:::tip Avantage du chiffrement sym√©trique

-   Tr√®s rapide.
-   Efficace pour gros volumes.
-   Math√©matiques simple.
-   Cl√©s courtes utilis√©s 128-256 bits.

:::

:::danger Inconv√©nients du chiffrement sym√©trique

-   Partage initial de cl√©.
-   Gestion complexe avec plusieurs utilisateurs.
-   Aucune authentification de l'exp√©diteur ( _Ce qui est critique pour la s√©curit√©_ ).
-   Si la cl√©e est compromise alors c'est tout le syst√®me qui devient vuln√©rable.

:::

**L'inconv√©nient majeur du chiffrement sym√©trique** r√©side dans le **partage initial de la cl√© secr√®te**. L'exp√©diteur et le destinataire
doivent n√©cessairement se transmettre ou convenir de cette cl√© au pr√©alable via un canal de communication s√©curis√©.

Cette exigence cr√©e **plusieurs vuln√©rabilit√©s critiques**, si la cl√© est intercept√©e pendant la phase d'√©change ou ult√©rieurement divulgu√©e,
**un attaquant disposera alors des moyens de d√©chiffrer l'int√©gralit√© des communications prot√©g√©es par cette cl√©**.

Cette interception peut survenir par diverses m√©thodes d'attaque, notamment l'utilisation de **proxies web malveillants** ou l'exploitation de
la faille classique connue sous le nom d'attaque "**Man In The Middle**" ( _homme du milieu_ ), o√π **l'attaquant s'interpose entre les deux
parties l√©gitimes** pour **intercepter** et **potentiellement modifier** leurs √©changes\*.

Au-del√† **des aspects s√©curitaires**, **la gestion op√©rationnelle** pose √©galement des d√©fis consid√©rables. Dans un environnement comportant
plusieurs correspondants distincts, **l'organisation doit maintenir et s√©curiser une multitude de cl√©s sym√©triques diff√©rentes**, cr√©ant une
complexit√© administrative croissante avec le nombre d'utilisateurs. Cette probl√©matique de passage √† l'√©chelle constitue l'une des limitations
fondamentales qui a motiv√© **le d√©veloppement des solutions de chiffrement asym√©trique**.

### Chiffrement **`asym√©trique`** ( _√† cl√© publique_ )

**Le chiffrement asym√©trique** r√©volutionne la gestion des cl√©s en fonctionnant avec **deux cl√©s diff√©rentes** par entit√© :

-   une **cl√© publique**
-   une **cl√© priv√©e**

Ces deux cl√©s forment une paire math√©matiquement li√©e. **La cl√© publique peut √™tre diffus√©e librement √† tout le monde**, tandis que
**la cl√© priv√©e est gard√©e secr√®te par son propri√©taire**. Ces deux cl√©s sont li√©es, **ce qui est chiffr√© avec l'une ne peut √™tre d√©chiffr√©
qu'avec l'autre**.

```mermaid
---
config:
    theme: 'neutral'
---
graph LR
    A[Bob g√©n√®re une paire de cl√©s] --> B[üîì Cl√© Publique<br/>Diffus√©e librement]
    A --> C[üîê Cl√© Priv√©e<br/>Gard√©e secr√®te]

    D[Alice veut envoyer<br/>un message secret √† Bob] --> E[R√©cup√®re la cl√© publique de Bob]
    E --> F[Chiffre son message<br/>avec la cl√© publique]
    F --> G[Transmet<br />le message chiffr√©]
    G --> H[Seul Bob peut d√©chiffrer<br/>avec sa cl√© priv√©e]

    style B fill:#e3e3f3
    style C fill:#f3e3e3
    style H fill:#e3f3e3
```

<br />

:::info Concr√®tement
Si **Bob** poss√®de un couple de **cl√©s asym√©triques**, le processus fonctionne ainsi :

1. **Bob publie sa cl√© publique** - Alice ( _ou quiconque_ ) qui veut lui envoyer un message secret r√©cup√®re cette cl√© publique
2. **Alice chiffre le message** √† l'aide de la cl√© publique de Bob
3. **Seul Bob peut d√©chiffrer** le message avec sa cl√© priv√©e secr√®te correspondante

:::

#### Processus d√©taill√© de communication asym√©trique

_Voici un diagramme de s√©quence pour mieux comprendre l'√©tape li√© au chiffrement asym√©trique._

```mermaid
---
config:
    theme: 'neutral'
---
sequenceDiagram
    participant A as Alice
    participant R as Annuaire Public<br/>des Cl√©s
    participant B as Bob

    Note over B: Bob g√©n√®re sa paire de cl√©s
    B->>B: G√©n√®re cl√© priv√©e (secr√®te)
    B->>B: Calcule cl√© publique correspondante
    B->>R: Publie sa cl√© publique

    Note over A: Alice veut envoyer un message secret
    A->>R: R√©cup√®re la cl√© publique de Bob
    A->>A: Chiffre "Message confidentiel"<br/>avec cl√© publique de Bob
    A->>B: Envoie message chiffr√© "Ky8nX5z..."

    B->>B: D√©chiffre avec sa cl√© priv√©e
    Note over B: R√©cup√®re "Message confidentiel"

    rect rgb(255, 240, 240)
        Note over A,B: Seul Bob peut d√©chiffrer car lui seul<br/>poss√®de la cl√© priv√©e correspondante
    end
```

Les algorithmes asym√©triques populaires incluent **RSA**, **ECC** ( _courbes elliptiques_ ), et **ElGamal**.
Ce type de chiffrement permet aussi d'impl√©menter des m√©canismes de **signature num√©rique** et d'**authentification**.

#### Signature num√©rique : l'usage inverse

> Le chiffrement asym√©trique permet √©galement de cr√©er des signatures num√©riques en inversant le processus :

```mermaid
---
config:
    theme: 'neutral'
---
graph TD
    A[Bob veut signer un document] --> B[Calcule empreinte du document<br/>avec fonction de hachage]
    B --> C[Chiffre l'empreinte avec<br/>sa cl√© PRIV√âE = signature]
    C --> D[Transmet document + signature]

    E[Alice re√ßoit document + signature] --> F[Calcule empreinte du document re√ßu]
    E --> G[D√©chiffre la signature avec<br/>cl√© PUBLIQUE de Bob]
    F --> H[Compare les deux empreintes]
    G --> H

    H --> I{Empreintes<br />identiques ?}
    I -->|Oui| J[‚úÖ Document authentique<br/>et non modifi√©]
    I -->|Non| K[‚ùå Document corrompu<br/>ou signature invalide]

    style A fill:#e3e3f3
    style E fill:#e3e3f3
    style I fill:#f3f3e3
    style J fill:#e3f3e3
    style K fill:#f3e3e3
```

:::info Signatures Num√©riques : JWT ( _JSON Web Tokens_ ) et SSH ( _Secure Shell_ )
Les signatures num√©riques inversent le processus de chiffrement asym√©trique pour garantir l'**authenticit√©** et l'**int√©grit√© des donn√©es**,
constituant ainsi des fondamentaux du SMSI et du triptyque CIA ( _Confidentialit√©, Int√©grit√©, Disponibilit√©_ ).

-   l'exp√©diteur signe avec sa cl√© priv√©e
-   le destinataire v√©rifie avec la cl√© publique correspondante

Les **JSON Web Tokens** ( _JWT_ ) constituent une impl√©mentation courante de ce principe, o√π les serveurs d'authentification **signent des
tokens** que les services applicatifs v√©rifient de mani√®re autonome avec la cl√© publique. Dans les **connexions SSH**, l'utilisateur prouve
son identit√© en **signant un d√©fi cryptographique avec sa cl√© priv√©e** que le **serveur v√©rifie avec la cl√© publique** correspondante.

Ces deux impl√©mentations illustrent comment les signatures num√©riques permettent l'authentification s√©curis√©e sans transmission de secrets
partag√©s.
:::

#### Comparaison sym√©trique vs asym√©trique

```mermaid
---
config:
    theme: 'neutral'
---
flowchart LR
    subgraph Comparaison[Crit√®res de Comparaison]
        subgraph Sym√©trique
            D[Vitesse: Tr√®s rapide<br/>Milliers de MB/s]
            E[Taille cl√©: 128-256 bits]
            F[Usage: Gros volumes<br/>Streaming, stockage]
            G[Gestion: Cl√© partag√©e<br/>Complex avec N users]
        end

        subgraph Asym√©trique
            H[Vitesse: Plus lent<br/>Quelques KB/s]
            I[Taille cl√©: 2048-4096 bits]
            J[Usage: √âchange de cl√©s<br/>Signatures, auth.]
            K[Gestion: Une paire par user<br/>Scalable]
        end
    end

    style Sym√©trique fill:#e3e3f3
    style Asym√©trique fill:#e3f3e3
```

### Chiffrement **`hybride`** ( _Meilleur choix ?_ )

En pratique, les syst√®mes modernes combinent les deux approches pour b√©n√©ficier de leurs avantages respectifs.
Cette technique s'appelle le **chiffrement hybride** et constitue la base de la plupart des protocoles s√©curis√©s contemporains.

```mermaid
---
config:
    theme: 'neutral'
---
graph TB
    subgraph Hybride[Communication Hybride]
        direction LR
        subgraph Sym√©trique
            C[Phase 2: Chiffrement Sym√©trique]
            C --> G[Chiffrement des donn√©es<br/>avec cl√© de session]
            C --> H[Performance optimale<br/>pour gros volumes]
            C --> I[S√©curit√© maintenue<br/>cl√© √©ph√©m√®re]
        end

        subgraph Asym√©trique
            B[Phase 1: Chiffrement Asym√©trique]
            B --> D[√âchange s√©curis√©<br/>d'une cl√© de session]
            B --> E[Authentification<br/>des parties]
            B --> F[√âtablissement<br/>canal de confiance]
        end
    end

    style B fill:#e3e3f3
    style C fill:#e3e3f3
```

:::note Le processus hybride fonctionne ainsi

On utilise l'asym√©trique pour √©changer de mani√®re s√©curis√©e une cl√© sym√©trique ( _appel√©e cl√© de session_ ), puis on utilise cette cl√©
sym√©trique pour chiffrer les donn√©es effectives.

_Ce sch√©ma est notamment appliqu√© lorsqu'on visite un site web en **HTTPS** : le **protocole TLS 1.3 ( s√©curis√© )** commence par un √©change de
cl√©s asym√©trique, puis bascule sur un algorithme sym√©trique pour le reste de la communication._

:::

## **Techniques connexes souvent confondues**

Il est fr√©quent de confondre le chiffrement avec d'autres proc√©d√©s de transformation de donn√©es.<br />
Les plus notables sont :

-   le **hachage cryptographique**
-   l'**encodage**
-   la **st√©ganographie**

Ces techniques ont des objectifs et des propri√©t√©s diff√©rentes qu'il convient de clarifier.

### **`Hachage cryptographique`**

Une **fonction de hachage** prend un message de longueur variable en entr√©e et calcule une empreinte ( _appel√©e hash_ ) de taille fixe en
sortie. Une propri√©t√© cruciale du hachage est qu'il s'agit d'un processus **non r√©versible** : **on ne peut pas retrouver le message d'origine
√† partir du hash.**

```mermaid
---
config:
    theme: 'neutral'
---
flowchart TB
    subgraph Description
        direction LR
        A[Message de<br/>longueur variable]
        B[Fonction de<br/>Hachage SHA-256]
        C[Empreinte fixe<br/>256 bits]

        A --> B --> C
    end

    subgraph Exemple
        D["Bonjour Omnyforge !"]
        E[SHA-256]
        F["a7b9c1d2e3f4..."]

        D --> E --> F
    end

    subgraph Properties[Propri√©t√©s Essentielles]
        direction TB
        H[Non r√©versible]
        I[D√©terministe]
        J[R√©sistant aux collisions]
        K[Effet avalanche]
    end

    Description --> Exemple
    Properties --> Exemple

    style C fill:#e3f3e3
    style H fill:#e3f3e3
    style I fill:#e3f3e3
    style J fill:#e3f3e3
    style K fill:#e3f3e3
```

#### Voici quelques explications d√©taill√©es pour √™tre v√©ritablement compr√©hensible\*

-   **Fonctionnement du hachage cryptographique**<br />
    _Le processus de hachage transforme syst√©matiquement un message de longueur arbitraire en une **empreinte num√©rique de taille fixe**.
    Cette transformation s'effectue selon des algorithmes math√©matiques pr√©cis qui garantissent quatre propri√©t√©s fondamentales essentielles
    √† la s√©curit√© informatique._

-   **Propri√©t√©s essentielles du hachage s√©curis√©**

    -   La propri√©t√© **non r√©versible** constitue le pilier de la s√©curit√© du hachage. _Contrairement au chiffrement qui permet de retrouver
        le message original avec la cl√© appropri√©e, **le hachage ne permet jamais de reconstituer le contenu initial √† partir de l'empreinte**.
        Cette caract√©ristique unidirectionnelle prot√®ge d√©finitivement les donn√©es sensibles telles que les mots de passe stock√©s dans les
        bases de donn√©es._

    -   Le caract√®re **d√©terministe** assure qu'un m√™me message produira toujours exactement la m√™me empreinte. _Ce concept permet ainsi la
        v√©rification fiable de l'int√©grit√© des donn√©es. Cette pr√©visibilit√© s'av√®re indispensable pour comparer les empreintes et d√©tecter
        les modifications non autoris√©es dans les fichiers ou les communications._

    -   La **r√©sistance aux collisions** garantit qu'il demeure computationnellement impossible de trouver deux messages diff√©rents produisant
        la m√™me empreinte. _Cette propri√©t√© pr√©serve l'**unicit√© des signatures num√©riques** et emp√™che la **falsification** des documents par
        **substitution malveillante**._

    -   **L'effet avalanche** amplifie consid√©rablement la s√©curit√© en modifiant drastiquement l'empreinte r√©sultante lors du moindre changement
        dans le message source. _**Une modification d'un seul caract√®re transforme compl√®tement l'empreinte**, r√©v√©lant imm√©diatement
        toute tentative d'alt√©ration des donn√©es originales._

Ces propri√©t√©s convergent pour faire du hachage cryptographique un instrument incontournable de v√©rification d'int√©grit√© et de protection des
informations sensibles dans les syst√®mes d'information modernes.

:::note Outil exploitant le hash : BCrypt
**Bcrypt** illustre parfaitement l'utilisation d'un **salt** ( _grain de sel_ ) pour **renforcer la s√©curit√© du hachage des mots de passe**.

Ce grain de sel ( _salt_ ) constitue une valeur al√©atoire unique ajout√©e au mot de passe avant le hachage, emp√™chant ainsi l'utilisation de
**tables de correspondance pr√©calcul√©es** ( _rainbow tables_ ). M√™me si le salt devient public, un attaquant ne peut plus exploiter des
dictionnaires de hashs pr√©compil√©s et doit recalculer chaque tentative individuellement, augmentant consid√©rablement le co√ªt computationnel
des attaques par force brute.

Cette technique transforme des mots de passe identiques en hashs uniques, √©liminant les vuln√©rabilit√©s li√©es aux mots de passe communs.
:::

#### Usage principal : v√©rification d'int√©grit√©

Le hachage sert principalement √† garantir **l'int√©grit√©** d'une information, c'est-√†-dire v√©rifier qu'elle n'a pas √©t√© alt√©r√©e.<br />
Voici un exemple concret de v√©rification d'int√©grit√© de fichier via un diagramme de s√©quence :

```mermaid
---
config:
    theme: 'neutral'
---
sequenceDiagram
    participant S as Exp√©diteur
    participant R as Destinataire

    Note over S: Pr√©paration de l'envoi
    S->>S: Calcule hash = SHA-256(Fichier)
    S->>S: hash = "a7b9c1d2e3f4..."

    Note over S,R: Transmission
    S->>R: Envoie Fichier
    S->>R: Envoie hash "a7b9c1d2e3f4..."

    Note over R: V√©rification c√¥t√© destinataire
    R->>R: Calcule hash du fichier re√ßu
    R->>R: hash_re√ßu = SHA-256(Fichier re√ßu)
    R->>R: Compare hash vs hash_re√ßu

    alt Hashs identiques
        Note over R: ‚úÖ Fichier int√®gre<br/>Aucune alt√©ration
    else Hashs diff√©rents
        Note over R: ‚ùå Fichier corrompu<br/>ou falsifi√©
    end
```

#### Stockage s√©curis√© des mots de passe

Le hachage est aussi couramment utilis√© pour stocker de fa√ßon s√©curis√©e des mots de passe :

**Phase 1 - Cr√©ation du Mot de passe**

:::warning
Ici, nous n'allons pas appliquer le salt pour ne pas complexifier l'information, mais dites-vous juste que le hash g√©n√©r√© ne sera pas celui qui sera stock√© dans la
base de donn√©es, n'oubliez pas le grain de sel qui s'ajoute avant et qui modifie ce hash pour le rendre unique. C'est ce hash unique qui sera stock√© dans la base de donn√©es.
:::

```mermaid
---
title: Phase 1 - Cr√©ation du Mot de passe
config:
    theme: 'neutral'
---
graph LR
    A[Utilisateur cr√©e<br/>mot de passe] -.->|MonMotDePasse123| B[Syst√®me calcule<br/>hash du mot de passe]
    B -->|785ec28bf8e52a439f1c9e81c4f...| C[(Stocke UNIQUEMENT<br/> le hash dans la BDD)]

    style C fill:#e3f3e3
```

```mermaid
---
title: Phase 2 - Tentative de connexion
config:
    theme: 'neutral'
---
graph LR
    USER[Utilisateur saisit<br/>son mot de passe]
    A[Syst√®me calcule hash<br/>du mot de passe saisi]
    B[(Base de donn√©es)]

    USER -.->|MonMotDePasse123| A -.->|Compare avec hash stock√©| B

    B --> C{Hashs identiques ?}
    C -->|Oui| D[‚úÖ Authentification r√©ussie]
    C -->|Non| E[‚ùå Mot de passe incorrect]

    style C fill:#f3f3e3
    style D fill:#e3f3e3
    style E fill:#f3e3e3
```

**Exemples de fonctions de hachage** : SHA-256, SHA-3, BLAKE2, HMAC, et l'**obsol√®te MD5**.

:::note √âvolution vers SHA-3 et Consid√©rations Futures
**La fonction de hachage SHA-3 repr√©sente l'√©tat de l'art actuel en mati√®re de s√©curit√© cryptographique** et constitue **la recommandation privil√©gi√©e pour les nouveaux
d√©veloppements**. Bien que l'av√®nement de l'informatique quantique soul√®ve des questions concernant la robustesse des algorithmes cryptographiques actuels, SHA-3 b√©n√©ficie
d'une conception moderne qui int√®gre les meilleures pratiques de r√©sistance aux attaques connues.

Les organisations soucieuses de p√©rennit√© s√©curitaire adoptent progressivement **SHA-3 dans leurs infrastructures critiques**. Cette migration s'inscrit dans une d√©marche de
veille technologique proactive, anticipant les √©volutions du paysage des menaces sans attendre les recommandations formelles des organismes de normalisation.

Sur les distributions Ubuntu, l'impl√©mentation de SHA-3 n√©cessite l'installation d'un paquet sp√©cialis√© pour acc√©der aux outils en ligne de commande correspondants.

```shell
# Mise √† jour des d√©p√¥ts de paquets
sudo apt update -y

# Installation du paquet fournissant les outils SHA-3
sudo apt install -y libdigest-sha3-perl

# Utilisation pour le calcul d'empreintes
sha3sum <chemin_vers_fichier>
```

_Cette approche permet aux √©quipes techniques de tester et √©valuer SHA-3 dans leurs environnements de d√©veloppement avant une √©ventuelle migration des syst√®mes de production._
:::

##

### **`L'encodage ( codage )`**

**Encodage** signifie convertir des donn√©es d'un format vers un autre selon un sch√©ma connu, **sans intention de secret**.<br />
C'est une transformation r√©versible publiquement, utilis√©e pour la compatibilit√© ou la transmission.

```mermaid
---
config:
    theme: 'neutral'
---
graph LR
    A[Donn√©es Originales] --> B{Type de<br />Transformation}

    B -->|Encodage| C[Format Diff√©rent<br/>R√©versible Publiquement]
    B -->|Chiffrement| D[Donn√©es Prot√©g√©es<br/>R√©versible avec Cl√© Secr√®te]

    C --> E[Base64: SGVsbG8=<br/>ASCII: binaire<br/>URL: %20 pour espace]
    D --> F[AES: donn√©es illisibles<br/>RSA: cl√© publique/priv√©e]

    E --> G[Objectif: Compatibilit√©<br/>Transport, Stockage]
    F --> H[Objectif: Confidentialit√©<br/>Protection contre espionnage]

    style B fill:#f3f3e3
    style C fill:#e3e3f3
    style D fill:#f3e3e3
```

#### Exemple concret : encodage Base64

```mermaid
---
config:
    theme: 'neutral'
---
graph LR
    A["Texte: 'Bonjour'"] --> B[Conversion en binaire]
    B --> C[Regroupement par 6 bits]
    C --> D[Mappage table Base64]
    D --> E["R√©sultat: 'Qm9uam91cg=='"]

    F[D√©codage Base64] --> G[Table de conversion publique]
    G --> H[Reconversion automatique]
    H --> I["Texte original: 'Bonjour'"]

    style E fill:#e3e3f3
    style I fill:#e3f3e3
```

:::note Diff√©rence essentielle
Un contenu **encod√© en Base64** peut √™tre **facilement d√©cod√© par n'importe qui** connaissant l'algorithme standard. Ce n'est pas un secret, simplement une autre
repr√©sentation des m√™mes donn√©es.
:::

:::danger Attention avec les JSON Web Tokens ( _JWT_ )
Pr√©c√©demment on a √©voqu√© cet outil qui permet l'authentification.
Ce qu'il faut savoir c'est que dans la g√©n√©ration de son **Payload**, **il ne faudra jamais passer une quelconque donn√©es sensibles**. En effet ce dernier est **encod√©e
en base64** et donc, si vous avez bien compris le concept de l'encodage alors vous aurez compris qu'il est tr√®s simple de d√©coder ce dernier et ainsi afficher des donn√©es
pour compromettre la soci√©t√© ou votre application en tant que tel.
:::

### **`La st√©ganographie`**

La **st√©ganographie** est l'art de dissimuler l'existence m√™me d'un message au sein d'un autre support anodin. Contrairement au chiffrement qui rend un message illisible mais
visible, la st√©ganographie cherche √† faire passer inaper√ßu le fait qu'il y a une communication secr√®te.

```mermaid
---
config:
    theme: 'neutral'
---
graph TD
    A[Message Secret] -.->|Rendez-vous √† 15h| B[Support de Dissimulation]

    B --> C[üì∑ Image Num√©rique]
    B --> D[üéµ Fichier Audio]
    B --> E[üìÑ Texte Anodin]

    C --> F[Modification LSB pixels<br/>Imperceptible √† l'≈ìil]
    D --> G[Fr√©quences inaudibles<br/>Spectre non utilis√©]
    E --> H[Espacement variable<br/>Caract√®res invisibles]

    F --> I[Image identique en apparence<br/>+ message cach√©]
    G --> J[Audio identique √† l'oreille<br/>+ donn√©es secr√®tes]
    H --> K[Texte normal en apparence<br/>+ information dissimul√©e]

    style A fill:#f3e3e3
    style B fill:#e3e3f3
    style I fill:#e3f3e3
    style J fill:#e3f3e3
    style K fill:#e3f3e3
```

#### Comparaison : Cryptographie vs St√©ganographie

```mermaid
---
config:
    theme: 'neutral'
---
graph TB
    A[Besoin de Protection] --> B[Cryptographie<br/>Cache le CONTENU]
    A --> C[St√©ganographie<br/>Cache l'EXISTENCE]

    B --> D[Message visible<br/>mais illisible]
    B --> E["Ex: 'X7k9mP2Q8...'<br/>Clairement chiffr√©"]
    B --> F[Utilise des cl√©s<br/>Algorithmes publics]

    C --> G[Message invisible<br/>Support anodin]
    C --> H["Ex: Photo de vacances<br/>contenant message secret"]
    C --> I[Utilise un support<br/>Technique de dissimulation]

    style A fill:#e3e3f3
    style B fill:#f3e3e3
    style C fill:#e3f3e3
```

:::info Limitation importante
_La st√©ganographie pure n'offre pas de garantie de confidentialit√© du contenu. Si le subterfuge est d√©couvert, le message cach√© peut √™tre en clair.
C'est pourquoi on combine souvent les deux techniques : **on chiffre d'abord le message**, puis **on le cache dans un support anodin**._
:::

## **Le chiffrement dans les communications r√©elles**

Pour assurer la confidentialit√© des √©changes sur les r√©seaux, on utilise le chiffrement dans divers **protocoles s√©curis√©s**. Le protocole **TLS**
( _Transport Layer Security_ ), qui sous-tend **HTTPS** pour le web s√©curis√©, constitue l'exemple le plus r√©pandu de ces impl√©mentations.

### Architecture d'une connexion HTTPS

> Avant d'examiner le **handshake TLS**, comprenons l'architecture compl√®te d'une connexion s√©curis√©e :

```mermaid
---
title: Connexion HTTPS Compl√®te
config:
    theme: 'neutral'
---
graph TD
    B[Couche Physique] -.->|C√¢bles, WiFi, Fibre| C[Couche R√©seau]
    C -.->|IP, Routage| D[Couche<br/>Transport TCP]
    D -->|Handshake 3-way| G[SYN ‚Üí SYN-ACK ‚Üí ACK]
    G -.->|√âtablit connexion fiable non s√©curis√©| F[Couche Application<br/>HTTP - Donn√©es m√©tier]
    F --> I[GET, POST non s√©curis√©s<br/>Donn√©es chiffr√©es]

    G -->|√âtablit connexion fiable s√©curis√©| E[Couche<br />S√©curit√© TLS]
    E -->|Handshake + Chiffrement| F[Couche Application<br/>HTTP - Donn√©es m√©tier]
    E <--> H[N√©gociation chiffrement<br/>√âchange de cl√©s]
    F --> J[GET, POST s√©curis√©s<br/>Donn√©es chiffr√©es]

    style E fill:#90EE90
```

### Le three-way handshake TCP

Avant d'aborder le **chiffrement avec TLS**, il convient de comprendre comment s'√©tablit la connexion de transport sous-jacente. Le **protocole TCP** utilise un m√©canisme
appel√© **three-way handshake** pour √©tablir une connexion fiable entre deux entit√©s. Cette proc√©dure garantit que les deux parties sont pr√™tes √† communiquer et synchronise
leurs param√®tres de connexion.

Le processus se d√©roule en **trois √©tapes distinctes** qui permettent d'√©tablir un **canal de communication bidirectionnel fiable** sur un **r√©seau potentiellement non
fiable** comme Internet.

```mermaid
---
title: √âtablissement d'une connexion TCP
config:
    theme: 'neutral'
---
sequenceDiagram
    participant A as Alice<br/>(Client)
    participant B as Bob<br/>(Serveur)

    Note over A,B: √âtablissement de la connexion TCP
    A->>B: SYN<br/>- Demande de connexion<br/>- S√©quence initiale = 1000<br/>- Port destination = 443

    Note over B: Bob accepte la connexion<br/>et pr√©pare ses param√®tres
    B->>A: SYN-ACK<br/>- Accus√© de r√©ception (ACK = 1001)<br/>- Propre s√©quence = 2000<br/>- Confirmation d'ouverture

    Note over A: Alice confirme la r√©ception<br/>des param√®tres de Bob
    A->>B: ACK<br/>- Accus√© de r√©ception (ACK = 2001)<br/>- Confirmation finale

    rect rgb(240, 255, 240)
        Note over A,B: ‚úÖ Connexion TCP √©tablie<br/>Canal bidirectionnel op√©rationnel
    end
```

#### Analyse du processus

1. Le message **SYN** initial initie la demande de connexion en transmettant les param√®tres de communication souhait√©s par le client. Cette √©tape annonce l'intention
   d'√©tablir une session et propose les conditions techniques de l'√©change.

2. La r√©ponse **SYN-ACK** du serveur remplit une double fonction en accusant r√©ception de la demande initiale tout en proposant ses propres param√®tres de connexion.
   Cette √©tape bidirectionnelle optimise l'efficacit√© du processus de n√©gociation.

3. L'accus√© de r√©ception final **ACK** confirme l'acceptation des param√®tres propos√©s par le serveur et marque l'ach√®vement de la phase d'√©tablissement.
   √Ä partir de ce moment, les deux parties peuvent √©changer des donn√©es de mani√®re fiable avec garantie de livraison et d√©tection d'erreurs.

> _Cette fondation du protocole TCP constitue le pr√©requis indispensable pour toute communication s√©curis√©e, car elle fournit la fiabilit√© de transport n√©cessaire aux
> protocoles de chiffrement qui s'appuient sur elle._

### Le handshake TLS d√©taill√©

Lorsqu'un client ( _votre navigateur_ ) se connecte √† un serveur en **HTTPS**, une **n√©gociation TLS** complexe a lieu au-dessus de la couche de transport fiable.
Cette n√©gociation √©tablit les param√®tres cryptographiques qui prot√©geront toutes les communications subs√©quentes. Voici le processus complet :

```mermaid
---
title: N√©gociation TLS au-dessus de TCP
config:
    theme: 'neutral'
---
sequenceDiagram
    participant C as üíª Client<br/>(Navigateur)
    participant S as üñ•Ô∏è Serveur Web<br/>(site HTTPS)

    Note over C,S: Phase 1 - N√©gociation des param√®tres
    C->>S: ClientHello<br/>- Versions TLS support√©es<br/>- Algorithmes propos√©s<br/>- Nombre al√©atoire client

    S->>C: ServerHello<br/>- Version TLS choisie<br/>- Algorithme s√©lectionn√©<br/>- Nombre al√©atoire serveur<br/>- CERTIFICAT (+ cl√© publique)

    Note over C,S: Phase 2 - Authentification du serveur
    C->>C: V√©rifie le certificat<br/>- Autorit√© de certification<br/>- Validit√© dates<br/>- Nom de domaine

    Note over C,S: Phase 3 - √âchange de secret
    C->>C: G√©n√®re secret pr√©-ma√Ætre<br/>(nombre al√©atoire)
    C->>C: Chiffre avec cl√© publique serveur
    C->>S: Envoie secret pr√©-ma√Ætre chiffr√©

    Note over C,S: Phase 4 - Calcul des cl√©s de session
    C->>C: Calcule cl√© session =<br/>f(secret, al√©a_client, al√©a_serveur)
    S->>S: D√©chiffre secret pr√©-ma√Ætre<br/>Calcule m√™me cl√© session

    Note over C,S: Phase 5 - Finalisation
    C->>S: "Finished" (chiffr√© avec cl√© session)
    S->>C: "Finished" (chiffr√© avec cl√© session)

    rect rgb(240, 255, 240)
        Note over C,S: üîí Connexion s√©curis√©e √©tablie<br/>Toutes communications futures chiffr√©es
    end
```

-   La phase de n√©gociation initiale permet aux deux parties d'identifier les capacit√©s cryptographiques communes et de s√©lectionner les algorithmes les plus robustes
    disponibles des deux c√¥t√©s. Cette n√©gociation adaptative garantit la compatibilit√© tout en maximisant le niveau de s√©curit√©.

-   L'authentification du serveur via **son certificat num√©rique** constitue une √©tape **critique** qui **pr√©vient les attaques par usurpation d'identit√©**.
    Le client v√©rifie la cha√Æne de confiance jusqu'√† une autorit√© de certification reconnue, validant ainsi l'authenticit√© du serveur contact√©.

-   L'√©change de secret exploite la **cryptographie asym√©trique** pour transmettre de mani√®re s√©curis√©e un √©l√©ment secret qui servira √† **g√©n√©rer les cl√©s sym√©triques** de
    session. Cette approche hybride combine la s√©curit√© de l'asym√©trique avec l'efficacit√© du sym√©trique pour les communications de donn√©es.

#### Ce que garantit ce processus

```mermaid
---
config:
    theme: 'neutral'
---
graph TD
    A[Handshake TLS R√©ussi] --> B[üîê Confidentialit√©]
    A --> C[üõ°Ô∏è Authentification]
    A --> D[üîí Int√©grit√©]

    B --> F[Cl√© de session partag√©e<br/>Chiffrement sym√©trique des donn√©es]
    C --> G[Certificat du serveur v√©rifi√©<br/>Assurance identit√©]
    D --> H[D√©tection des modifications<br/>Messages authentifi√©s]

    style A fill:#e3f3e3
```

Ce processus combin√© **TCP** + **TLS** garantit l'√©tablissement d'un canal de communication √† la fois fiable et s√©curis√©, r√©pondant aux exigences de **confidentialit√©**,
d'**int√©grit√©** et d'**authentification** n√©cessaires aux √©changes sensibles sur des r√©seaux publics.

:::note
_Nous restons conformes au triptyque CIA d'un SMSI._
:::

### Protocole Diffie-Hellman moderne

Dans les versions r√©centes de **TLS**, on utilise souvent l'√©change de cl√©s **Diffie-Hellman** qui √©vite de transmettre un secret pr√©-chiffr√© :

```mermaid
---
config:
    theme: 'neutral'
---
sequenceDiagram
    participant A as Alice (Client)
    participant B as Bob (Serveur)

    Note over A,B: Param√®tres DH publics et connus

    A->>A: G√©n√®re nombre priv√© secret 'a'<br/>Calcule A = g^a mod p
    B->>B: G√©n√®re nombre priv√© secret 'b'<br/>Calcule B = g^b mod p

    A->>B: Envoie A (valeur publique)
    B->>A: Envoie B (valeur publique)

    Note over A,B: Calcul du secret partag√©
    A->>A: Secret = B^a mod p
    B->>B: Secret = A^b mod p

    rect rgb(240, 255, 240)
        Note over A,B: - M√™me secret calcul√© des deux c√¥t√©s<br/>- Un observateur ne peut pas<br />le calculer car il ne conna√Æt ni 'a' ni 'b'
    end
```

**L√©gende** : _**p** ( nombre premier ) & **g** ( g√©n√©rateur )_

#### Param√®tres cryptographiques fondamentaux

Les param√®tres **p** et **g** constituent les fondements math√©matiques du protocole Diffie-Hellman et requi√®rent une attention particuli√®re dans leur s√©lection et leur usage.

:::note Le param√®tre p
Il repr√©sente un **nombre premier de tr√®s grande taille**, typiquement de 2048 bits ou plus dans les impl√©mentations actuelles. Cette taille garantit la s√©curit√© contre les
tentatives de cassage par force brute ou analyse math√©matique avanc√©e.
:::

:::note Le param√®tre g
Il constitue un **g√©n√©rateur du groupe multiplicatif modulo p** qui permet de cr√©er un large √©ventail de valeurs distinctes lors des calculs cryptographiques. Cette
propri√©t√© assure une distribution suffisamment √©tendue des valeurs publiques √©chang√©es, pr√©venant ainsi les attaques par analyse statistique.
:::

Ces deux param√®tres demeurent publics et standardis√©s. Les organismes de normalisation tels que le **NIST** publient des jeux de param√®tres **p** et **g valid√©s** pour les
d√©ploiements professionnels. Cette approche standardis√©e facilite l'interop√©rabilit√© entre syst√®mes tout en maintenant les garanties de s√©curit√© requises.

La robustesse du protocole Diffie-Hellman repose sur l'impossibilit√© pratique pour un attaquant de calculer les valeurs secr√®tes √† partir des informations publiques
√©chang√©es. Cette propri√©t√© permet l'√©tablissement d'un secret partag√© sur des canaux non s√©curis√©s, constituant ainsi l'un des piliers des communications cryptographiques
contemporaines dans les environnements d'entreprise.

### Autres protocoles de s√©curit√©

TLS n'est pas le seul protocole utilisant ces principes. Voici un aper√ßu des autres protocoles courants :

```mermaid
---
config:
    theme: 'neutral'
---
flowchart TB
    A[Protocoles de S√©curit√© Modernes]

    subgraph WEB[üåê Web et APIs]
        F[HTTPS/TLS<br/>Chiffrement hybride]
        G[WebRTC<br/>Communication temps r√©el]
    end

    subgraph Messagerie[üìß Messagerie]
        H[S/MIME<br/>Email s√©curis√©]
        I[Signal Protocol<br/>Messagerie bout-en-bout]
    end

    subgraph Acc√®sDistant[üñ•Ô∏è Acc√®s Distant]
        J[SSH<br/>Terminal s√©curis√©]
    K[RDP s√©curis√©<br/>Bureau √† distance]
    end

    subgraph ReseauxPriv√©s[üîó R√©seaux Priv√©s]
        L[VPN IPSec<br/>Tunnel r√©seau]
        M[OpenVPN<br/>Connexion chiffr√©e]
    end

    A --> WEB & Messagerie & Acc√®sDistant & ReseauxPriv√©s
```

## **Applications pratiques et recommandations**

### Matrice de choix technologique

Pour s√©lectionner l'approche **cryptographique optimale** selon les **exigences op√©rationnelles sp√©cifiques**, cette matrice de d√©cision fournit un cadre d'√©valuation
structur√© permettant aux **√©quipes techniques** et aux **responsables s√©curit√©** de choisir les solutions les mieux adapt√©es √† leurs contextes d'usage.

| **Crit√®re d'√âvaluation**        | **Condition Sp√©cifique**  | **Technologie Recommand√©e**     | **Justification Technique**                     |
| ------------------------------- | ------------------------- | ------------------------------- | ----------------------------------------------- |
| **Volume de Donn√©es**           | Petits volumes (< 1 MB)   | Chiffrement Asym√©trique         | Acceptable malgr√© la surcharge computationnelle |
|                                 | Gros volumes (> 1 MB)     | Chiffrement Sym√©trique          | Performance optimale pour traitement massif     |
| **Contraintes Performance**     | Applications temps r√©el   | AES-256, ChaCha20               | Latence minimale, d√©bit √©lev√©                   |
|                                 | Traitement en diff√©r√©     | RSA acceptable                  | Contraintes temporelles rel√¢ch√©es               |
| **Niveau de S√©curit√©**          | S√©curit√© standard         | AES-256, RSA-2048               | Conformit√© r√©glementaire courante               |
|                                 | Haute s√©curit√© critique   | AES-256, RSA-4096+              | Protection renforc√©e donn√©es sensibles          |
| **Infrastructure de Cl√©s**      | PKI d√©ploy√©e              | Chiffrement Asym√©trique         | Exploitation infrastructure existante           |
|                                 | Canal s√©curis√© disponible | Chiffrement Sym√©trique          | √âchange pr√©alable de cl√©s possible              |
| **Contraintes Op√©rationnelles** | Authentification requise  | Solutions hybrides + signatures | Garantie identit√© et confidentialit√©            |
|                                 | Int√©grit√© prioritaire     | Fonctions de hachage + MAC      | D√©tection alt√©rations critiques                 |

Cette **matrice de d√©cision** permet une **√©valuation syst√©matique des options technologiques** en fonction des **contraintes sp√©cifiques de chaque projet**.
Les recommandations pr√©sent√©es refl√®tent les meilleures pratiques industrielles actuelles et respectent les standards de s√©curit√© reconnus par les **organismes
de normalisation internationaux**.

### Cycle de vie s√©curis√© d'une communication

L'√©tablissement d'une communication s√©curis√©e en environnement professionnel n√©cessite une orchestration rigoureuse de multiples phases techniques et s√©curitaires. Ce
processus d√©passe largement la simple n√©gociation initiale des param√®tres cryptographiques pour englober un cycle de vie complet garantissant la confidentialit√©, l'int√©grit√©
et la disponibilit√© ( _triptyque CIA d'un SMSI_ ) des √©changes tout au long de leur dur√©e de vie op√©rationnelle.

:::note
_Le diagramme de s√©quence ci-dessous illustrent l'approche recommand√©e pour les communications critiques d'entreprise, int√©grant les meilleures pratiques de s√©curit√©
informatique contemporaines et respectant les exigences de conformit√© r√©glementaire applicables aux organisations traitant des donn√©es sensibles._
:::

#### Phase 1 - N√©gociation et Initiation

La phase de n√©gociation initiale constitue le fondement de toute communication s√©curis√©e robuste. Cette √©tape √©tablit les param√®tres cryptographiques optimaux support√©s par
l'ensemble des participants, pr√©venant ainsi les vuln√©rabilit√©s associ√©es aux algorithmes obsol√®tes ou affaiblis. Le syst√®me s√©curis√© analyse les capacit√©s d√©clar√©es par
chaque partie pour s√©lectionner la combinaison d'algorithmes offrant le niveau de protection maximal compatible avec les contraintes op√©rationnelles de l'environnement.

```mermaid
---
title: Phase 1 - N√©gociation et Initiation
config:
    theme: 'neutral'
---
sequenceDiagram
    participant U1 as Utilisateur 1
    participant S as Syst√®me S√©curis√©
    participant U2 as Utilisateur 2

    Note over U1,U2: 1. Initiation et n√©gociation
    U1->>S: Demande communication + param√®tres support√©s
    S->>U2: Notification demande de U1
    U2->>S: Acceptation + param√®tres support√©s
    S->>S: N√©gociation algorithmes optimaux
    S->>S: G√©n√©ration cl√©s de session
```

#### Phase 2 - Authentification mutuelle et validation des autorisations

L'authentification mutuelle garantit la l√©gitimit√© de tous les participants avant l'√©tablissement du canal de communication. Cette v√©rification bidirectionnelle pr√©vient
efficacement les attaques par usurpation d'identit√©, quelle que soit leur origine. Le processus inclut non seulement la validation des identit√©s mais √©galement la
v√©rification des autorisations sp√©cifiques requises pour acc√©der aux ressources concern√©es par la communication envisag√©e.

```mermaid
---
title: Phase 2 - Authentification mutuelle et validation des autorisations
config:
    theme: 'neutral'
---
sequenceDiagram
    participant U1 as Utilisateur 1
    participant S as Syst√®me S√©curis√©
    participant U2 as Utilisateur 2

    Note over U1,U2: 2. Authentification mutuelle
    S->>U1: D√©fi d'authentification
    U1->>S: Preuve d'identit√© (certificat/biom√©trie)
    S->>U2: D√©fi d'authentification
    U2->>S: Preuve d'identit√© (certificat/token)
    S->>S: Validation identit√©s et autorisations
```

#### Phase 3 - √âtablissement et validation du canal s√©curis√©

La confirmation de r√©ception des √©l√©ments cryptographiques assure la synchronisation parfaite des param√®tres de s√©curit√© avant le commencement des √©changes op√©rationnels.
Cette validation crois√©e √©limine les risques de d√©synchronisation qui pourraient compromettre l'int√©grit√© ou la confidentialit√© des communications subs√©quentes.

```mermaid
---
title: Phase 3 - √âtablissement et validation du canal s√©curis√©
config:
    theme: 'neutral'
---
sequenceDiagram
    participant U1 as Utilisateur 1
    participant S as Syst√®me S√©curis√©
    participant U2 as Utilisateur 2

    Note over U1,U2: 3. √âtablissement canal s√©curis√©
    S->>U1: Cl√© session + param√®tres (chiffr√©s)
    S->>U2: Cl√© session + param√®tres (chiffr√©s)
    U1->>S: Confirmation r√©ception et validation
    U2->>S: Confirmation r√©ception et validation
    S->>S: Validation √©tablissement canal
```

#### Phase 4 - Communication op√©rationnelle et surveillance continue

Durant la phase op√©rationnelle, l'int√©grit√© des messages b√©n√©ficie d'une protection renforc√©e via des codes d'authentification qui d√©tectent toute alt√©ration ou injection
malveillante. La surveillance continue de la session permet l'identification proactive des anomalies comportementales ou des tentatives d'intrusion, maintenant ainsi un
niveau de s√©curit√© optimal pendant toute la dur√©e de vie de la communication.

```mermaid
---
title: Phase 4 - Communication op√©rationnelle et surveillance continue
config:
    theme: 'neutral'
---
sequenceDiagram
    participant U1 as Utilisateur 1
    participant S as Syst√®me S√©curis√©
    participant U2 as Utilisateur 2

    Note over U1,U2: 4. Communication op√©rationnelle
    U1->>U2: Messages chiffr√©s + MAC d'int√©grit√©
    U2->>U1: Accus√© r√©ception + r√©ponses chiffr√©es
    S->>S: Surveillance session (timeouts, anomalies)
```

#### Phase 5 - Gestion proactive des incidents de s√©curit√©

Les m√©canismes de gestion des incidents fournissent des capacit√©s de r√©action imm√©diate en cas de compromission d√©tect√©e. Cette approche proactive inclut la r√©vocation
instantan√©e des mat√©riels cryptographiques compromis et la notification synchrone de tous les participants concern√©s par l'incident s√©curitaire.

```mermaid
---
title: Phase 5 - Gestion proactive des incidents de s√©curit√©
config:
    theme: 'neutral'
---
sequenceDiagram
    participant U1 as Utilisateur 1
    participant S as Syst√®me S√©curis√©
    participant U2 as Utilisateur 2

    Note over U1,U2: 5. Gestion des incidents
    alt D√©tection d'anomalie
        S->>U1: Alerte s√©curitaire
        S->>U2: Alerte s√©curitaire
        S->>S: R√©vocation imm√©diate des cl√©s
    end
```

#### Phase 6 - Terminaison contr√¥l√©e et conformit√© r√©glementaire

La terminaison contr√¥l√©e garantit la fermeture ordonn√©e de la session avec destruction s√©curis√©e de l'ensemble des √©l√©ments sensibles. Cette phase g√©n√®re √©galement les
traces d'audit indispensables √† la conformit√© r√©glementaire et aux exigences de gouvernance informatique des organisations d'entreprise.

```mermaid
---
title: Phase 6 - Terminaison contr√¥l√©e et conformit√© r√©glementaire
config:
    theme: 'neutral'
---
sequenceDiagram
    participant U1 as Utilisateur 1
    participant S as Syst√®me S√©curis√©
    participant U2 as Utilisateur 2

    Note over U1,U2: 6. Terminaison contr√¥l√©e
    U1->>S: Demande fermeture session
    S->>U2: Notification fin de session
    U2->>S: Accus√© r√©ception fermeture
    S->>S: Destruction s√©curis√©e cl√©s + logs audit
    S->>U1: Confirmation terminaison
    Note over U1,U2: Session ferm√©e - Aucune trace cryptographique
```

> Cette approche m√©thodologique refl√®te les standards de s√©curit√© exig√©s dans les environnements professionnels o√π la protection des donn√©es, la tra√ßabilit√© des acc√®s et la
> r√©silience op√©rationnelle constituent des imp√©ratifs strat√©giques incontournables pour la continuit√© des activit√©s et la pr√©servation de la r√©putation organisationnelle.

### Recommandations de s√©curit√© actuelles

```mermaid
---
config:
    theme: 'neutral'
---
flowchart LR
    subgraph GOOD[Bonnes Pratiques 2025]
        B[Algorithmes]
        C[Tailles de Cl√©s]
        D[Gestion Avanc√©e]
        E[Transition Post-Quantique]

        B --> F[‚úÖ AES-256<br/>‚úÖ ChaCha20<br/>‚úÖ Algorithmes Hybrides<br/>‚ùå DES/3DES]
        B --> G[‚úÖ RSA-4096+<br/>‚úÖ ECC P-521<br/>‚ùå RSA-2048]
        C --> H[Sym√©trique: 256 bits<br/>Asym√©trique: 4096+ bits<br/>Post-Quantique: Variables]
        D --> I[Rotation trimestrielle<br/>HSM certifi√©s FIPS 140-3<br/>Zero Trust Architecture<br/>Chiffrement bout-en-bout]
        E --> J[Migration hybride obligatoire<br/>Standards NIST finalis√©s<br/>Audits de compatibilit√©<br/>Formation √©quipes techniques]
    end

    style F fill:#e3f3e3
    style G fill:#e3f3e3
    style H fill:#e3e3f3
    style I fill:#f3f3e3
    style J fill:#f3e3e3
```

:::danger Important
L'√©volution rapide du paysage technologique **impose une r√©vision continue des pratiques de s√©curit√© informatique**. Les recommandations pour 2025 refl√®tent l'√©mergence de
nouvelles menaces et **l'av√®nement de technologies disruptives qui transforment fondamentalement les approches traditionnelles de protection des donn√©es**.
:::

#### √âvolution des algorithmes de chiffrement

Les algorithmes hybrides constituent d√©sormais une n√©cessit√© strat√©gique pour les organisations soucieuses de maintenir leur niveau de s√©curit√© tout en pr√©parant l'avenir.
Cette approche combine intelligemment les m√©thodes cryptographiques classiques, dont la fiabilit√© a √©t√© d√©montr√©e au fil des d√©cennies, avec les nouvelles technologies
post-quantiques. Cette strat√©gie permet aux entreprises de conserver la compatibilit√© avec leurs syst√®mes existants sans compromettre leur capacit√© d'adaptation aux
√©volutions technologiques futures.

Les algorithmes traditionnels tels qu'**AES-256** et **ChaCha20** conservent leur statut de **r√©f√©rences incontournables pour le chiffrement sym√©trique**.
Leur robustesse √©prouv√©e et leur efficacit√© op√©rationnelle les maintiennent au c≈ìur des architectures de s√©curit√© contemporaines. En revanche, **les technologies obsol√®tes
comme DES et 3DES doivent imp√©rativement √™tre abandonn√©es en raison de leurs vuln√©rabilit√©s d√©sormais exploitables par des moyens de calcul accessibles**.

#### Renforcement des param√®tres cryptographiques

L'augmentation des tailles de cl√©s asym√©triques vers un minimum de **4096 bits pour RSA** r√©pond directement √† l'√©volution des capacit√©s de calcul disponibles et √† la
sophistication croissante des attaques informatiques. Cette progression technique n√©cessaire assure le maintien d'un niveau de protection ad√©quat face aux ressources
computationnelles modernes.

Les courbes elliptiques √©voluent parall√®lement vers des param√®tres plus robustes, avec **P-521** qui devient la nouvelle r√©f√©rence pour les d√©ploiements n√©cessitant un
niveau de s√©curit√© √©lev√©. Cette migration technique garantit la p√©rennit√© des investissements en infrastructure cryptographique tout en anticipant les d√©fis s√©curitaires
des prochaines ann√©es.

#### Modernisation de la gestion des cl√©s

La gestion avanc√©e des cl√©s int√®gre d√©sormais les principes **Zero Trust** qui r√©volutionnent les architectures de s√©curit√© d'entreprise. Cette approche fondamentale modifie
**la philosophie traditionnelle de la s√©curit√© p√©rim√©trique en imposant une v√©rification syst√©matique de chaque acc√®s**, ind√©pendamment de son origine g√©ographique ou
organisationnelle.

**La rotation trimestrielle des cl√©s cryptographiques** devient **la pratique standard** pour les environnements traitant des informations sensibles. Cette fr√©quence accrue
de renouvellement, support√©e par des modules de s√©curit√© mat√©rielle certifi√©s selon les derniers standards **FIPS 140-3**, r√©duit significativement la fen√™tre d'exposition
en cas de compromission et renforce la r√©silience globale des syst√®mes.

#### Pr√©paration √† la r√©volution post-quantique

La transition vers la **cryptographie post-quantique** repr√©sente l'enjeu technologique majeur de 2025. La finalisation des standards par les organismes de normalisation
internationaux, notamment le **NIST am√©ricain**, impose aux organisations une obligation d'adaptation pour pr√©server la s√©curit√© de leurs actifs informationnels face √†
l'√©mergence annonc√©e des ordinateurs quantiques.

Cette migration technologique majeure n√©cessite **un investissement substantiel en formation sp√©cialis√©e pour les √©quipes techniques**, qui doivent **ma√Ætriser les nouveaux
paradigmes cryptographiques** tout en g√©rant la coexistence temporaire avec les syst√®mes existants. Les audits de compatibilit√© deviennent √©galement indispensables pour
identifier les composants n√©cessitant une mise √† niveau prioritaire et planifier une transition progressive qui minimise les risques op√©rationnels.

> L'ensemble de ces √©volutions r√©pond aux d√©fis √©mergents de cybers√©curit√© tout en positionnant les infrastructures critiques pour les transformations technologiques
> anticip√©es. Cette approche proactive permet aux organisations de maintenir leur avantage concurrentiel tout en assurant la protection continue de leurs actifs
> informationnels dans un environnement de menaces en constante √©volution.

## **Conclusion**

Le chiffrement des donn√©es constitue un pilier fondamental de la s√©curit√© informatique moderne. La distinction terminologique entre **chiffrer** ( _avec cl√©_ ) et **crypter** ( _anglicisme incorrect_ ) refl√®te une compr√©hension pr√©cise des m√©canismes sous-jacents.

Les syst√®mes s√©curis√©s contemporains s'appuient sur une approche hybride combinant la robustesse du chiffrement asym√©trique pour l'√©change de cl√©s et l'efficacit√© du chiffrement sym√©trique pour la protection des donn√©es volumineuses. Cette architecture, illustr√©e dans les protocoles comme TLS/HTTPS, d√©montre comment la cryptographie th√©orique se traduit en solutions pratiques et performantes.

Les techniques connexes ( _hachage, encodage, st√©ganographie_ ) compl√®tent l'arsenal cryptographique en r√©pondant √† des besoins sp√©cifiques d'int√©grit√©, de compatibilit√© ou de discr√©tion. Leur compr√©hension permet d'√©viter les confusions courantes et de choisir la solution appropri√©e selon le contexte.

L'√©volution vers la cryptographie post-quantique et les d√©fis √©mergents n√©cessitent une veille technologique constante. Cependant, les principes fondamentaux pr√©sent√©s dans ce guide restent valides et constituent la base n√©cessaire pour appr√©hender les d√©veloppements futurs de la s√©curit√© informatique.

---

> _Ce guide s'appuie sur les standards industriels et les recommandations des organismes de s√©curit√© reconnus (ANSSI, NIST) pour fournir une compr√©hension solide et actuelle des technologies de chiffrement._

-   Lien vers l'Agence nationale de la s√©curit√© des syst√®mes d'information ( ANSSI ) : **[https://cyber.gouv.fr/](https://cyber.gouv.fr/)**
-   Lien vers "National Institute of Standards and Technology" ( NIST ) : **[https://www.nist.gov/](https://www.nist.gov/)**
